# Code Execution in Google ADK

The `google.adk` library provides a flexible code execution system that allows agents to execute code generated by LLMs. This capability is managed through the `code_executor` parameter in the `LlmAgent` class.

## Overview

The library defines a `BaseCodeExecutor` interface, allowing for various execution backends. This means you are not limited to cloud-based execution; you can run code locally, either directly or within a sandbox.

## Available Executors

The following executors are available in `google.adk.code_executors`:

### 1. Local Sandboxed Execution (Recommended for Local Use)

- **Class**: `ContainerCodeExecutor`
- **Description**: Executes code inside a local Docker container. This provides a secure sandbox environment on your local machine.
- **Requirements**:
  - Docker must be installed and running on your machine.
  - You can specify a pre-built image or a path to a Dockerfile.

**Usage Example:**

```python
from google.adk.code_executors.container_code_executor import ContainerCodeExecutor
from google.adk.agents.llm_agent import LlmAgent

# Initialize the executor with a specific Docker image
executor = ContainerCodeExecutor(image='python:3.10-slim')

# Or build from a local Dockerfile
# executor = ContainerCodeExecutor(docker_path='./path/to/docker_dir')

# Pass the executor to your agent
agent = LlmAgent(
    name="analyst_agent",
    code_executor=executor,
    # ... other configuration ...
)
```

### 2. Local Direct Execution (Unsafe)

- **Class**: `UnsafeLocalCodeExecutor`
- **Description**: Executes code directly in the current Python process using `exec()`.
- **Warning**: **Use with extreme caution.** This executor has no isolation. The agent can access your file system, environment variables, and network just like your main application. It is primarily useful for testing in trusted environments or for agents that specifically need to manipulate the local environment.

**Usage Example:**

```python
from google.adk.code_executors.unsafe_local_code_executor import UnsafeLocalCodeExecutor
from google.adk.agents.llm_agent import LlmAgent

executor = UnsafeLocalCodeExecutor()

agent = LlmAgent(
    name="local_script_agent",
    code_executor=executor,
    # ... other configuration ...
)
```

### 3. Cloud-Based Execution

The library also supports cloud-based execution environments for production and scalable deployments:

- **`VertexAICodeExecutor`**: Uses Google Cloud Vertex AI for code execution.
- **`GKECodeExecutor`**: Uses Google Kubernetes Engine.
- **`AgentEngineSandboxCodeExecutor`**: Uses Vertex AI Agent Engine Sandboxes.

## Configuring the Agent

To enable code execution for an agent, simply instantiate the desired executor class and pass it to the `LlmAgent` constructor via the `code_executor` parameter.

```python
agent = LlmAgent(
    model="gemini-1.5-pro",
    code_executor=ContainerCodeExecutor(image='python:3.10'),
    # ...
)
```

## Running Shell Commands

The code execution system is designed to run **Python code**. However, you can execute shell commands by invoking them through Python's `subprocess` module.

**Example:**

```python
import subprocess

# Run a shell command
result = subprocess.run(['ls', '-la'], capture_output=True, text=True)
print(result.stdout)
```

- **In `ContainerCodeExecutor`**: The command runs inside the Docker container. This is safe and isolated.
- **In `UnsafeLocalCodeExecutor`**: The command runs directly on your host machine. **This is extremely dangerous** as it allows the agent to execute any command on your computer.

## How Does the LLM Know When to Execute Code?

This is a critical question! The system uses **special delimiters** to distinguish executable code from demonstration code.

### Code Block Delimiters

When you configure a `code_executor`, the system looks for specific markdown code block types:

1.  **````tool_code`** - The **primary** delimiter for executable code
2.  **````python`** - A **fallback** delimiter (also executable if a code executor is configured)

**Example of executable code:**

````markdown
```tool_code
print("This will be executed!")
```
````

**Example of demonstration code (won't execute):**

````markdown
Here's how you might implement it:

```
print("This is just an example")
```
````

### System Instructions

**Important: The system does NOT automatically inject instructions about `tool_code` into the agent's prompt.**

You must explicitly instruct your agent about when to use executable code blocks. Here's what you should add to your agent's `instruction`:

````yaml
instruction: |
  You are a helpful assistant with code execution capabilities.

  When you need to execute code to answer a question or perform a task:
  - Use ```tool_code blocks for code that should be executed
  - The code will run in a sandboxed environment
  - You will receive the output and can use it in your response

  When you're just showing example code for demonstration:
  - Use regular code blocks without the tool_code marker
````

### Built-in Code Executor (Gemini 2.0+)

There's a special case: `BuiltInCodeExecutor` uses Gemini's native code execution feature. This works differently:

- **Execution Location**: Code runs on **Google's backend servers** via the Gemini API (not locally or in your sandbox)
- It registers code execution as a **tool** in the model's configuration
- The model decides when to use it (like any other tool)
- No special markdown delimiters or instructions needed
- Only works with Gemini 2.0+ models

```python
from google.adk.code_executors.built_in_code_executor import BuiltInCodeExecutor

agent = LlmAgent(
    model="gemini-2.0-flash-exp",
    code_executor=BuiltInCodeExecutor(),
    # ...
)
```

**Note**: Unlike `ContainerCodeExecutor` or `UnsafeLocalCodeExecutor`, this executor sends code to Google's servers for execution, so it's not suitable if you need to access local files or resources.

### Important Notes

- If you use `ContainerCodeExecutor` or `UnsafeLocalCodeExecutor`, **any** ````python` block will be executed
- This means you should carefully instruct your agent about when to use code blocks
- Consider using only ````tool_code` in your instructions to avoid ambiguity
