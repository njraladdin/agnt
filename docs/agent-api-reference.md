# Agent API Reference

This guide provides a comprehensive reference for the REST API exposed by ADK agents. Use this API to integrate agents into your frontend applications, mobile apps, or any HTTP client.

## Overview

The ADK API server provides RESTful endpoints for:

- **Session Management** - Create, retrieve, update, and delete conversation sessions
- **Agent Execution** - Run agents with user messages and receive responses
- **Artifact Management** - Store and retrieve files generated by agents
- **Memory Management** - Add sessions to long-term memory
- **Evaluation** - Create and run evaluation sets for testing agents

## Base URL

When running locally:

```
http://localhost:8000
```

For deployed agents, use your Cloud Run or custom deployment URL.

## Authentication

> [!NOTE]
> The built-in API server does not include authentication by default. For production deployments, implement authentication middleware before exposing your API publicly.

## Core Concepts

### Sessions

A **session** represents a conversation between a user and an agent. Sessions maintain:

- Conversation history (events)
- Session state (key-value pairs)
- User and app context

### Events

An **event** is a single interaction in a conversation, such as:

- User message
- Agent response
- Function call
- Function response
- State update

### Streaming vs Non-Streaming

- **Non-streaming**: Returns all events after the agent completes processing
- **Streaming (SSE)**: Returns events as they are generated in real-time

---

## API Endpoints

### List Available Agents

Get a list of all available agents.

```http
GET /list-apps
```

**Query Parameters:**

- `detailed` (boolean, optional) - Return detailed app information

**Response (simple):**

```json
["my_agent", "another_agent"]
```

**Response (detailed):**

```json
{
  "apps": [
    {
      "name": "my_agent",
      "rootAgentName": "MyAgent",
      "description": "A helpful assistant",
      "language": "python"
    }
  ]
}
```

---

### Session Management

#### Create Session

Create a new conversation session.

```http
POST /apps/{app_name}/users/{user_id}/sessions
```

**Path Parameters:**

- `app_name` (string) - Name of the agent
- `user_id` (string) - Unique identifier for the user

**Request Body (optional):**

```json
{
  "session_id": "custom-session-id",
  "state": {
    "key": "value"
  },
  "events": []
}
```

**Request Fields:**

- `session_id` (string, optional) - Custom session ID. If not provided, a UUID will be generated
- `state` (object, optional) - Initial session state
- `events` (array, optional) - Initial events to populate the session

**Response:**

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "appName": "my_agent",
  "userId": "user123",
  "state": {},
  "events": [],
  "timestamp": 1234567890.123
}
```

**Example:**

```javascript
const response = await fetch(
  "http://localhost:8000/apps/my_agent/users/user123/sessions",
  {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      state: { language: "en" },
    }),
  }
);
const session = await response.json();
console.log("Session ID:", session.id);
```

---

#### Get Session

Retrieve a specific session.

```http
GET /apps/{app_name}/users/{user_id}/sessions/{session_id}
```

**Response:**

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "appName": "my_agent",
  "userId": "user123",
  "state": {},
  "events": [
    {
      "id": "evt_123",
      "invocationId": "inv_456",
      "author": "user",
      "content": {
        "role": "user",
        "parts": [{ "text": "Hello!" }]
      },
      "timestamp": 1234567890.123
    }
  ],
  "timestamp": 1234567890.123
}
```

---

#### List Sessions

List all sessions for a user.

```http
GET /apps/{app_name}/users/{user_id}/sessions
```

**Response:**

```json
[
  {
    "id": "session_1",
    "appName": "my_agent",
    "userId": "user123",
    "state": {},
    "events": [...],
    "timestamp": 1234567890.123
  }
]
```

---

#### Update Session State

Update session state without running the agent.

```http
PATCH /apps/{app_name}/users/{user_id}/sessions/{session_id}
```

**Request Body:**

```json
{
  "stateDelta": {
    "language": "es",
    "theme": "dark"
  }
}
```

**Response:**
Returns the updated session object.

---

#### Delete Session

Delete a session and its history.

```http
DELETE /apps/{app_name}/users/{user_id}/sessions/{session_id}
```

**Response:** 200 OK (no body)

---

### Running the Agent

#### Run Agent (Non-Streaming)

Execute the agent and receive all events after completion.

```http
POST /run
```

**Request Body:**

```json
{
  "appName": "my_agent",
  "userId": "user123",
  "sessionId": "550e8400-e29b-41d4-a716-446655440000",
  "newMessage": {
    "role": "user",
    "parts": [{ "text": "What's the weather like?" }]
  },
  "streaming": false,
  "stateDelta": {
    "location": "San Francisco"
  }
}
```

**Request Fields:**

- `appName` (string, required) - Name of the agent
- `userId` (string, required) - User identifier
- `sessionId` (string, required) - Session identifier
- `newMessage` (object, required) - User message content
- `streaming` (boolean, optional) - Whether to stream responses (default: false)
- `stateDelta` (object, optional) - State updates to apply
- `invocationId` (string, optional) - For resuming long-running functions

**Response:**

```json
[
  {
    "id": "evt_789",
    "invocationId": "inv_456",
    "author": "my_agent",
    "content": {
      "role": "model",
      "parts": [{ "text": "The weather in San Francisco is sunny and 72Â°F." }]
    },
    "actions": {},
    "timestamp": 1234567890.456
  }
]
```

**Example:**

```javascript
const response = await fetch("http://localhost:8000/run", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    appName: "my_agent",
    userId: "user123",
    sessionId: sessionId,
    newMessage: {
      role: "user",
      parts: [{ text: "Hello, agent!" }],
    },
  }),
});

const events = await response.json();
events.forEach((event) => {
  if (event.content?.parts) {
    event.content.parts.forEach((part) => {
      if (part.text) {
        console.log("Agent:", part.text);
      }
    });
  }
});
```

---

#### Run Agent (Server-Sent Events)

Execute the agent with real-time streaming responses.

```http
POST /run_sse
```

**Request Body:** Same as `/run` endpoint

**Response:** Server-Sent Events stream

**Example:**

```javascript
const response = await fetch("http://localhost:8000/run_sse", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    appName: "my_agent",
    userId: "user123",
    sessionId: sessionId,
    newMessage: {
      role: "user",
      parts: [{ text: "Tell me a story" }],
    },
    streaming: true,
  }),
});

const reader = response.body.getReader();
const decoder = new TextDecoder();

while (true) {
  const { done, value } = await reader.read();
  if (done) break;

  const chunk = decoder.decode(value);
  const lines = chunk.split("\n");

  for (const line of lines) {
    if (line.startsWith("data: ")) {
      const eventData = JSON.parse(line.slice(6));
      console.log("Event:", eventData);

      // Process the event
      if (eventData.content?.parts) {
        eventData.content.parts.forEach((part) => {
          if (part.text) {
            console.log("Agent (streaming):", part.text);
          }
        });
      }
    }
  }
}
```

---

### Artifact Management

Artifacts are files generated or used by agents (images, documents, data files, etc.).

#### Save Artifact

Upload an artifact to a session.

```http
POST /apps/{app_name}/users/{user_id}/sessions/{session_id}/artifacts
```

**Request Body:**

```json
{
  "filename": "report.pdf",
  "artifact": {
    "inlineData": {
      "mimeType": "application/pdf",
      "data": "base64_encoded_data"
    }
  },
  "customMetadata": {
    "description": "Monthly report"
  }
}
```

**Response:**

```json
{
  "version": 1,
  "timestamp": 1234567890.123,
  "customMetadata": {
    "description": "Monthly report"
  }
}
```

---

#### Load Artifact

Retrieve an artifact from a session.

```http
GET /apps/{app_name}/users/{user_id}/sessions/{session_id}/artifacts/{artifact_name}?version=1
```

**Query Parameters:**

- `version` (integer, optional) - Specific version to load. If omitted, returns latest version

**Response:**

```json
{
  "inlineData": {
    "mimeType": "application/pdf",
    "data": "base64_encoded_data"
  }
}
```

---

#### List Artifacts

List all artifact names in a session.

```http
GET /apps/{app_name}/users/{user_id}/sessions/{session_id}/artifacts
```

**Response:**

```json
["report.pdf", "chart.png", "data.json"]
```

---

#### List Artifact Versions

List all versions of a specific artifact.

```http
GET /apps/{app_name}/users/{user_id}/sessions/{session_id}/artifacts/{artifact_name}/versions
```

**Response:**

```json
[1, 2, 3]
```

---

### Memory Management

#### Add Session to Memory

Add a session to the agent's long-term memory.

```http
POST /apps/{app_name}/users/{user_id}/sessions/{session_id}/memory
```

**Request Body:**

```json
{
  "sessionId": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Response:** 200 OK

---

## Event Structure

Events are the core data structure representing interactions in a conversation.

### Event Object

```typescript
interface Event {
  id: string; // Unique event identifier
  invocationId: string; // Invocation this event belongs to
  author: string; // "user" or agent name
  content?: Content; // Message content
  actions?: EventActions; // Actions taken by the agent
  longRunningToolIds?: string[]; // IDs of long-running function calls
  branch?: string; // Event branch (for multi-agent scenarios)
  timestamp: number; // Unix timestamp
  partial?: boolean; // Whether this is a partial event (streaming)
}
```

### Content Object

```typescript
interface Content {
  role: "user" | "model";
  parts: Part[];
}

interface Part {
  text?: string; // Text content
  inlineData?: {
    // Binary data (images, files)
    mimeType: string;
    data: string; // Base64 encoded
  };
  functionCall?: FunctionCall; // Tool/function invocation
  functionResponse?: FunctionResponse; // Tool/function result
  codeExecutionResult?: {
    // Code execution output
    outcome: string;
    output: string;
  };
}
```

### Function Call Object

```typescript
interface FunctionCall {
  id: string;
  name: string;
  args: Record<string, any>;
}
```

### Function Response Object

```typescript
interface FunctionResponse {
  id: string;
  name: string;
  response: any;
}
```

### Event Actions

```typescript
interface EventActions {
  stateDelta?: Record<string, any>; // State changes
  skipSummarization?: boolean; // Skip event summarization
}
```

---

## Common Patterns

### Pattern 1: Simple Chat Interface

```javascript
class AgentChat {
  constructor(baseUrl, appName, userId) {
    this.baseUrl = baseUrl;
    this.appName = appName;
    this.userId = userId;
    this.sessionId = null;
  }

  async initialize() {
    // Create session
    const response = await fetch(
      `${this.baseUrl}/apps/${this.appName}/users/${this.userId}/sessions`,
      { method: "POST" }
    );
    const session = await response.json();
    this.sessionId = session.id;
  }

  async sendMessage(text) {
    const response = await fetch(`${this.baseUrl}/run`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        appName: this.appName,
        userId: this.userId,
        sessionId: this.sessionId,
        newMessage: {
          role: "user",
          parts: [{ text }],
        },
      }),
    });

    const events = await response.json();

    // Extract agent responses
    return events
      .filter((e) => e.author !== "user")
      .flatMap((e) => e.content?.parts || [])
      .filter((p) => p.text)
      .map((p) => p.text)
      .join("");
  }
}

// Usage
const chat = new AgentChat("http://localhost:8000", "my_agent", "user123");
await chat.initialize();
const response = await chat.sendMessage("Hello!");
console.log(response);
```

---

### Pattern 2: Streaming Chat with React

```jsx
import { useState, useCallback } from "react";

function StreamingChat({ baseUrl, appName, userId }) {
  const [sessionId, setSessionId] = useState(null);
  const [messages, setMessages] = useState([]);
  const [isStreaming, setIsStreaming] = useState(false);

  const initializeSession = useCallback(async () => {
    const response = await fetch(
      `${baseUrl}/apps/${appName}/users/${userId}/sessions`,
      { method: "POST" }
    );
    const session = await response.json();
    setSessionId(session.id);
  }, [baseUrl, appName, userId]);

  const sendMessage = useCallback(
    async (text) => {
      if (!sessionId) return;

      // Add user message
      setMessages((prev) => [...prev, { role: "user", text }]);
      setIsStreaming(true);

      const response = await fetch(`${baseUrl}/run_sse`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          appName,
          userId,
          sessionId,
          newMessage: {
            role: "user",
            parts: [{ text }],
          },
          streaming: true,
        }),
      });

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let currentMessage = "";

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value);
        const lines = chunk.split("\n");

        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const event = JSON.parse(line.slice(6));

            if (event.content?.parts) {
              event.content.parts.forEach((part) => {
                if (part.text) {
                  currentMessage += part.text;
                  setMessages((prev) => {
                    const newMessages = [...prev];
                    const lastMsg = newMessages[newMessages.length - 1];

                    if (lastMsg?.role === "agent") {
                      lastMsg.text = currentMessage;
                    } else {
                      newMessages.push({ role: "agent", text: currentMessage });
                    }

                    return newMessages;
                  });
                }
              });
            }
          }
        }
      }

      setIsStreaming(false);
    },
    [baseUrl, appName, userId, sessionId]
  );

  return (
    <div>
      <div className="messages">
        {messages.map((msg, i) => (
          <div key={i} className={msg.role}>
            {msg.text}
          </div>
        ))}
      </div>
      <input
        onKeyPress={(e) => {
          if (e.key === "Enter" && !isStreaming) {
            sendMessage(e.target.value);
            e.target.value = "";
          }
        }}
        disabled={isStreaming}
      />
    </div>
  );
}
```

---

### Pattern 3: Python Client

```python
import requests
from typing import List, Dict, Any

class AgentClient:
    def __init__(self, base_url: str, app_name: str, user_id: str):
        self.base_url = base_url
        self.app_name = app_name
        self.user_id = user_id
        self.session_id = None

    def create_session(self, initial_state: Dict[str, Any] = None) -> str:
        """Create a new session."""
        response = requests.post(
            f"{self.base_url}/apps/{self.app_name}/users/{self.user_id}/sessions",
            json={"state": initial_state} if initial_state else {}
        )
        response.raise_for_status()
        session = response.json()
        self.session_id = session["id"]
        return self.session_id

    def send_message(self, text: str, state_delta: Dict[str, Any] = None) -> str:
        """Send a message and get the agent's response."""
        if not self.session_id:
            raise ValueError("No active session. Call create_session() first.")

        payload = {
            "appName": self.app_name,
            "userId": self.user_id,
            "sessionId": self.session_id,
            "newMessage": {
                "role": "user",
                "parts": [{"text": text}]
            }
        }

        if state_delta:
            payload["stateDelta"] = state_delta

        response = requests.post(f"{self.base_url}/run", json=payload)
        response.raise_for_status()
        events = response.json()

        # Extract agent text responses
        agent_responses = []
        for event in events:
            if event.get("author") != "user" and event.get("content"):
                for part in event["content"].get("parts", []):
                    if "text" in part:
                        agent_responses.append(part["text"])

        return " ".join(agent_responses)

    def get_session_history(self) -> List[Dict[str, Any]]:
        """Get the full session history."""
        if not self.session_id:
            raise ValueError("No active session.")

        response = requests.get(
            f"{self.base_url}/apps/{self.app_name}/users/{self.user_id}/sessions/{self.session_id}"
        )
        response.raise_for_status()
        session = response.json()
        return session.get("events", [])

    def delete_session(self):
        """Delete the current session."""
        if not self.session_id:
            return

        requests.delete(
            f"{self.base_url}/apps/{self.app_name}/users/{self.user_id}/sessions/{self.session_id}"
        )
        self.session_id = None

# Usage
client = AgentClient("http://localhost:8000", "my_agent", "user123")
client.create_session(initial_state={"language": "en"})

response = client.send_message("What's the weather?")
print(f"Agent: {response}")

history = client.get_session_history()
print(f"Total events: {len(history)}")

client.delete_session()
```

---

## Error Handling

### HTTP Status Codes

- `200 OK` - Request successful
- `400 Bad Request` - Invalid request format or parameters
- `404 Not Found` - Resource not found (session, artifact, etc.)
- `409 Conflict` - Resource already exists (e.g., duplicate session ID)
- `500 Internal Server Error` - Server error during processing

### Error Response Format

```json
{
  "detail": "Session not found"
}
```

### Example Error Handling

```javascript
async function sendMessageSafely(message) {
  try {
    const response = await fetch("http://localhost:8000/run", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        appName: "my_agent",
        userId: "user123",
        sessionId: sessionId,
        newMessage: {
          role: "user",
          parts: [{ text: message }],
        },
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.detail || "Request failed");
    }

    return await response.json();
  } catch (error) {
    console.error("Failed to send message:", error);

    // Handle specific errors
    if (error.message.includes("Session not found")) {
      // Recreate session
      await createNewSession();
    }

    throw error;
  }
}
```

---

## WebSocket Support (Real-time Bidirectional Communication)

The API server provides a WebSocket endpoint for **real-time, bidirectional communication** with agents. This is ideal for:

- Live chat applications
- Voice/audio interactions
- Real-time collaborative agents
- Low-latency interactions

### WebSocket Endpoint

```
ws://localhost:8000/run_live
```

**Query Parameters:**

- `app_name` (string, required) - Name of the agent
- `user_id` (string, required) - User identifier
- `session_id` (string, required) - Session ID (must be created first)
- `modalities` (array, optional) - Array of `TEXT` and/or `AUDIO` (default: `["TEXT", "AUDIO"]`)

### How It Works

The WebSocket connection is **bidirectional**:

- **Client â†’ Server**: Send `LiveRequest` objects with user input
- **Server â†’ Client**: Receive `Event` objects as the agent responds in real-time

### LiveRequest Format

You can send different types of requests over the WebSocket:

```typescript
// Text message
{
  "content": {
    "role": "user",
    "parts": [{ "text": "Your message" }]
  }
}

// Audio blob (for realtime mode)
{
  "blob": {
    "mimeType": "audio/pcm",
    "data": "base64_audio_data"
  }
}

// Activity signals
{ "activityStart": {} }  // User started typing/speaking
{ "activityEnd": {} }    // User finished typing/speaking

// Close connection
{ "close": true }
```

### JavaScript Example

```javascript
// 1. Create session first
const response = await fetch(
  "http://localhost:8000/apps/my_agent/users/user123/sessions",
  { method: "POST" }
);
const session = await response.json();

// 2. Connect to WebSocket
const ws = new WebSocket(
  `ws://localhost:8000/run_live?app_name=my_agent&user_id=user123&session_id=${session.id}&modalities=TEXT`
);

ws.onopen = () => {
  console.log("WebSocket connected");

  // Send a message
  ws.send(
    JSON.stringify({
      content: {
        role: "user",
        parts: [{ text: "Hello, agent!" }],
      },
    })
  );
};

ws.onmessage = (event) => {
  const agentEvent = JSON.parse(event.data);
  console.log("Received event:", agentEvent);

  // Process the event (see Function Call Detection section)
  if (agentEvent.content?.parts) {
    agentEvent.content.parts.forEach((part) => {
      if (part.text) {
        console.log("Agent:", part.text);
      }
    });
  }
};

ws.onerror = (error) => {
  console.error("WebSocket error:", error);
};

ws.onclose = (event) => {
  console.log("WebSocket closed:", event.code, event.reason);
};

// 3. Send activity signals (optional)
function onUserStartTyping() {
  ws.send(JSON.stringify({ activityStart: {} }));
}

function onUserStopTyping() {
  ws.send(JSON.stringify({ activityEnd: {} }));
}

// 4. Close connection when done
function disconnect() {
  ws.send(JSON.stringify({ close: true }));
  ws.close();
}
```

### Audio Streaming Example

```javascript
// For voice/audio interactions
const ws = new WebSocket(
  `ws://localhost:8000/run_live?app_name=my_agent&user_id=user123&session_id=${sessionId}&modalities=AUDIO&modalities=TEXT`
);

// Send audio chunks
function sendAudioChunk(audioData) {
  const base64Audio = btoa(String.fromCharCode(...new Uint8Array(audioData)));

  ws.send(
    JSON.stringify({
      blob: {
        mimeType: "audio/pcm",
        data: base64Audio,
      },
    })
  );
}

// Receive audio responses
ws.onmessage = (event) => {
  const agentEvent = JSON.parse(event.data);

  if (agentEvent.content?.parts) {
    agentEvent.content.parts.forEach((part) => {
      // Handle audio response
      if (part.inlineData?.mimeType.startsWith("audio/")) {
        playAudio(part.inlineData.data);
      }
      // Handle text response
      if (part.text) {
        displayText(part.text);
      }
    });
  }
};
```

---

## Detecting and Displaying Agent Actions

All agent actions (function calls, tool usage, code execution) are **fully exposed** in the event structure. You can display everything transparently without any custom backend code.

### What You Can Detect

Every event can contain:

1. **Text responses** - Agent's natural language output
2. **Function calls** - Tools the agent is using
3. **Function responses** - Results from tool execution
4. **Code execution** - Python code run by the agent
5. **Media** - Images, files, audio generated or used

### Event Processing Function

```javascript
function processAgentEvent(event) {
  if (!event.content?.parts) return [];

  const actions = [];

  event.content.parts.forEach((part) => {
    // 1. Text responses
    if (part.text) {
      actions.push({
        type: "text",
        content: part.text,
      });
    }

    // 2. Function calls (tool usage)
    if (part.functionCall) {
      actions.push({
        type: "function_call",
        name: part.functionCall.name,
        args: part.functionCall.args,
        id: part.functionCall.id,
      });
    }

    // 3. Function responses (tool results)
    if (part.functionResponse) {
      actions.push({
        type: "function_response",
        name: part.functionResponse.name,
        response: part.functionResponse.response,
        id: part.functionResponse.id,
      });
    }

    // 4. Code execution results
    if (part.codeExecutionResult) {
      actions.push({
        type: "code_execution",
        outcome: part.codeExecutionResult.outcome,
        output: part.codeExecutionResult.output,
      });
    }

    // 5. Images/files
    if (part.inlineData) {
      actions.push({
        type: "media",
        mimeType: part.inlineData.mimeType,
        data: part.inlineData.data,
      });
    }
  });

  return actions;
}

// Usage
const actions = processAgentEvent(event);
actions.forEach((action) => {
  switch (action.type) {
    case "text":
      displayMessage(action.content);
      break;
    case "function_call":
      displayToolUsage(action.name, action.args);
      break;
    case "function_response":
      displayToolResult(action.name, action.response);
      break;
    case "code_execution":
      displayCodeExecution(action.outcome, action.output);
      break;
    case "media":
      displayMedia(action.mimeType, action.data);
      break;
  }
});
```

### Typical Event Flow Example

When an agent uses tools, you'll receive multiple events in sequence:

```javascript
// Event 1: Agent decides to use a tool
{
  "id": "evt_1",
  "author": "my_agent",
  "content": {
    "role": "model",
    "parts": [
      {
        "functionCall": {
          "id": "fc_123",
          "name": "get_weather",
          "args": { "location": "San Francisco" }
        }
      }
    ]
  }
}
// Display: "ðŸ”§ Agent is using get_weather tool..."

// Event 2: Tool execution result
{
  "id": "evt_2",
  "author": "user",  // Function responses come from "user"
  "content": {
    "role": "user",
    "parts": [
      {
        "functionResponse": {
          "id": "fc_123",
          "name": "get_weather",
          "response": {
            "temperature": 72,
            "condition": "sunny",
            "humidity": 65
          }
        }
      }
    ]
  }
}
// Display: "âœ… Weather data retrieved"

// Event 3: Agent's final response using the data
{
  "id": "evt_3",
  "author": "my_agent",
  "content": {
    "role": "model",
    "parts": [
      {
        "text": "The weather in San Francisco is sunny and 72Â°F with 65% humidity."
      }
    ]
  }
}
// Display: "The weather in San Francisco is..."
```

---

## Best Practices

### 1. Session Management

- **Create sessions once** and reuse them for the entire conversation
- **Store session IDs** in your application state (localStorage, database, etc.)
- **Clean up sessions** when conversations end to save resources
- **Handle session expiration** gracefully by creating new sessions

### 2. Error Handling

- **Always check HTTP status codes** before processing responses
- **Implement retry logic** for transient failures
- **Validate session existence** before making requests
- **Handle network errors** gracefully

### 3. Streaming

- **Use SSE for long responses** to provide better UX
- **Handle partial events** correctly in streaming mode
- **Implement proper cleanup** of streaming connections
- **Show loading indicators** during streaming

### 4. Performance

- **Reuse HTTP connections** when possible
- **Implement request timeouts** to prevent hanging
- **Cache session data** to reduce API calls
- **Use pagination** for large session lists

### 5. Security

- **Never expose API keys** in frontend code
- **Implement authentication** for production deployments
- **Validate user input** before sending to agents
- **Use HTTPS** in production
- **Implement rate limiting** to prevent abuse

---

## CORS Configuration

For web applications, configure CORS when starting the API server:

```bash
adk api_server ./agents --allow_origins http://localhost:3000
```

Or programmatically:

```python
from google.adk.cli.fast_api import get_fast_api_app

app = get_fast_api_app(
    agents_dir="./agents",
    allow_origins=["http://localhost:3000", "https://myapp.com"],
    web=False
)
```

---

## Next Steps

- See [deploying-agents.md](deploying-agents.md) for deployment options
- See [running-agents-programmatically.md](running-agents-programmatically.md) for local development
- See [browser-automation.md](browser-automation.md) for browser-based agents
- See [memory-system.md](memory-system.md) for memory configuration
